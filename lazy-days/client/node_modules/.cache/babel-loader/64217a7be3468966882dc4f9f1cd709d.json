{"ast":null,"code":"import { Component, createElement } from 'react';\nimport { __extends, __rest, __read, __assign } from 'tslib';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.js';\nimport { VisibilityAction } from '../../../components/AnimateSharedLayout/types.js';\nimport { axisBox } from '../../../utils/geometry/index.js';\nimport { eachAxis } from '../../../utils/each-axis.js';\nimport { startAnimation } from '../../../animation/utils/transitions.js';\nimport { tweenAxis } from './utils.js';\nvar progressTarget = 1000;\nvar Animate = /** @class */function (_super) {\n  __extends(Animate, _super);\n  function Animate() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A mutable object that tracks the target viewport box\n     * for the current animation frame.\n     */\n    _this.frameTarget = axisBox();\n    /**\n     * The current animation target, we use this to check whether to start\n     * a new animation or continue the existing one.\n     */\n    _this.currentAnimationTarget = axisBox();\n    /**\n     * Track whether we're animating this axis.\n     */\n    _this.isAnimating = {\n      x: false,\n      y: false\n    };\n    _this.stopAxisAnimation = {\n      x: undefined,\n      y: undefined\n    };\n    _this.isAnimatingTree = false;\n    _this.animate = function (target, origin, _a) {\n      if (_a === void 0) {\n        _a = {};\n      }\n      var originBox = _a.originBox,\n        targetBox = _a.targetBox,\n        visibilityAction = _a.visibilityAction,\n        shouldStackAnimate = _a.shouldStackAnimate,\n        onComplete = _a.onComplete,\n        config = __rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\", \"shouldStackAnimate\", \"onComplete\"]);\n      var _b = _this.props,\n        visualElement = _b.visualElement,\n        layout = _b.layout;\n      /**\n       * Early return if we've been instructed not to animate this render.\n       */\n      if (shouldStackAnimate === false) {\n        _this.isAnimatingTree = false;\n        return _this.safeToRemove();\n      }\n      /**\n       * Prioritise tree animations\n       */\n      if (_this.isAnimatingTree && shouldStackAnimate !== true) {\n        return;\n      } else if (shouldStackAnimate) {\n        _this.isAnimatingTree = true;\n      }\n      /**\n       * Allow the measured origin (prev bounding box) and target (actual layout) to be\n       * overridden by the provided config.\n       */\n      origin = originBox || origin;\n      target = targetBox || target;\n      var boxHasMoved = hasMoved(origin, target);\n      var animations = eachAxis(function (axis) {\n        /**\n         * If layout is set to \"position\", we can resize the origin box based on the target\n         * box and only animate its position.\n         */\n        if (layout === \"position\") {\n          var targetLength = target[axis].max - target[axis].min;\n          origin[axis].max = origin[axis].min + targetLength;\n        }\n        if (visualElement.projection.isTargetLocked) {\n          return;\n        } else if (visibilityAction !== undefined) {\n          visualElement.setVisibility(visibilityAction === VisibilityAction.Show);\n        } else if (boxHasMoved) {\n          // If the box has moved, animate between it's current visual state and its\n          // final state\n          return _this.animateAxis(axis, target[axis], origin[axis], config);\n        } else {\n          // If the box has remained in the same place, immediately set the axis target\n          // to the final desired state\n          return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max);\n        }\n      });\n      // Force a render to ensure there's no flash of uncorrected bounding box.\n      visualElement.syncRender();\n      /**\n       * If this visualElement isn't present (ie it's been removed from the tree by the user but\n       * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\n       * have successfully finished.\n       */\n      return Promise.all(animations).then(function () {\n        _this.isAnimatingTree = false;\n        onComplete && onComplete();\n        visualElement.notifyLayoutAnimationComplete();\n      });\n    };\n    return _this;\n  }\n  Animate.prototype.componentDidMount = function () {\n    var _this = this;\n    var visualElement = this.props.visualElement;\n    visualElement.animateMotionValue = startAnimation;\n    visualElement.enableLayoutProjection();\n    this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n    visualElement.layoutSafeToRemove = function () {\n      return _this.safeToRemove();\n    };\n  };\n  Animate.prototype.componentWillUnmount = function () {\n    var _this = this;\n    this.unsubLayoutReady();\n    eachAxis(function (axis) {\n      var _a, _b;\n      return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n  /**\n   * TODO: This manually performs animations on the visualElement's layout progress\n   * values. It'd be preferable to amend the startLayoutAxisAnimation\n   * API to accept more custom animations like this.\n   */\n  Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n    var _this = this;\n    var _b, _c;\n    var transition = (_a === void 0 ? {} : _a).transition;\n    /**\n     * If we're not animating to a new target, don't run this animation\n     */\n    if (this.isAnimating[axis] && axisIsEqual(target, this.currentAnimationTarget[axis])) {\n      return;\n    }\n    (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n    this.isAnimating[axis] = true;\n    var visualElement = this.props.visualElement;\n    var frameTarget = this.frameTarget[axis];\n    var layoutProgress = visualElement.getProjectionAnimationProgress()[axis];\n    /**\n     * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\n     * be re-incoporated into a subsequent spring animation.\n     */\n    layoutProgress.clearListeners();\n    layoutProgress.set(0);\n    layoutProgress.set(0);\n    /**\n     * Create an animation function to run once per frame. This will tween the visual bounding box from\n     * origin to target using the latest progress value.\n     */\n    var frame = function () {\n      // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n      var p = layoutProgress.get() / progressTarget;\n      // Tween the axis and update the visualElement with the latest values\n      tweenAxis(frameTarget, origin, target, p);\n      visualElement.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max);\n    };\n    // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n    frame();\n    // Ensure that the layout delta is updated for this frame.\n    visualElement.updateLayoutProjection();\n    // Create a function to stop animation on this specific axis\n    var unsubscribeProgress = layoutProgress.onChange(frame);\n    this.stopAxisAnimation[axis] = function () {\n      _this.isAnimating[axis] = false;\n      layoutProgress.stop();\n      unsubscribeProgress();\n    };\n    this.currentAnimationTarget[axis] = target;\n    // Start the animation on this axis\n    var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, transition || this.props.transition || defaultTransition).then(this.stopAxisAnimation[axis]);\n    return animation;\n  };\n  Animate.prototype.safeToRemove = function () {\n    var _a, _b;\n    (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n  };\n  Animate.prototype.render = function () {\n    return null;\n  };\n  return Animate;\n}(Component);\nfunction AnimateLayoutContextProvider(props) {\n  var _a = __read(usePresence(), 2),\n    safeToRemove = _a[1];\n  return createElement(Animate, __assign({}, props, {\n    safeToRemove: safeToRemove\n  }));\n}\nfunction hasMoved(a, b) {\n  return !isZeroBox(a) && !isZeroBox(b) && (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y));\n}\nvar zeroAxis = {\n  min: 0,\n  max: 0\n};\nfunction isZeroBox(a) {\n  return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);\n}\nfunction axisIsEqual(a, b) {\n  return a.min === b.min && a.max === b.max;\n}\nvar defaultTransition = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\n/**\n * @public\n */\nvar AnimateLayout = {\n  key: \"animate-layout\",\n  shouldRender: function (props) {\n    return !!props.layout || props.layoutId !== undefined;\n  },\n  getComponent: function () {\n    return AnimateLayoutContextProvider;\n  }\n};\nexport { AnimateLayout };","map":{"version":3,"names":["Component","createElement","__extends","__rest","__read","__assign","usePresence","VisibilityAction","axisBox","eachAxis","startAnimation","tweenAxis","progressTarget","Animate","_super","_this","apply","arguments","frameTarget","currentAnimationTarget","isAnimating","x","y","stopAxisAnimation","undefined","isAnimatingTree","animate","target","origin","_a","originBox","targetBox","visibilityAction","shouldStackAnimate","onComplete","config","_b","props","visualElement","layout","safeToRemove","boxHasMoved","hasMoved","animations","axis","targetLength","max","min","projection","isTargetLocked","setVisibility","Show","animateAxis","setProjectionTargetAxis","syncRender","Promise","all","then","notifyLayoutAnimationComplete","prototype","componentDidMount","animateMotionValue","enableLayoutProjection","unsubLayoutReady","onLayoutUpdate","layoutSafeToRemove","componentWillUnmount","call","_c","transition","axisIsEqual","layoutProgress","getProjectionAnimationProgress","clearListeners","set","frame","p","get","updateLayoutProjection","unsubscribeProgress","onChange","stop","animation","defaultTransition","render","AnimateLayoutContextProvider","a","b","isZeroBox","zeroAxis","duration","ease","AnimateLayout","key","shouldRender","layoutId","getComponent"],"sources":["/home/pc/Desktop/react-projects/react-projects/lazy-days/client/node_modules/framer-motion/dist/es/motion/features/layout/Animate.js"],"sourcesContent":["import { Component, createElement } from 'react';\nimport { __extends, __rest, __read, __assign } from 'tslib';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.js';\nimport { VisibilityAction } from '../../../components/AnimateSharedLayout/types.js';\nimport { axisBox } from '../../../utils/geometry/index.js';\nimport { eachAxis } from '../../../utils/each-axis.js';\nimport { startAnimation } from '../../../animation/utils/transitions.js';\nimport { tweenAxis } from './utils.js';\n\nvar progressTarget = 1000;\nvar Animate = /** @class */ (function (_super) {\n    __extends(Animate, _super);\n    function Animate() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A mutable object that tracks the target viewport box\n         * for the current animation frame.\n         */\n        _this.frameTarget = axisBox();\n        /**\n         * The current animation target, we use this to check whether to start\n         * a new animation or continue the existing one.\n         */\n        _this.currentAnimationTarget = axisBox();\n        /**\n         * Track whether we're animating this axis.\n         */\n        _this.isAnimating = {\n            x: false,\n            y: false,\n        };\n        _this.stopAxisAnimation = {\n            x: undefined,\n            y: undefined,\n        };\n        _this.isAnimatingTree = false;\n        _this.animate = function (target, origin, _a) {\n            if (_a === void 0) { _a = {}; }\n            var originBox = _a.originBox, targetBox = _a.targetBox, visibilityAction = _a.visibilityAction, shouldStackAnimate = _a.shouldStackAnimate, onComplete = _a.onComplete, config = __rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\", \"shouldStackAnimate\", \"onComplete\"]);\n            var _b = _this.props, visualElement = _b.visualElement, layout = _b.layout;\n            /**\n             * Early return if we've been instructed not to animate this render.\n             */\n            if (shouldStackAnimate === false) {\n                _this.isAnimatingTree = false;\n                return _this.safeToRemove();\n            }\n            /**\n             * Prioritise tree animations\n             */\n            if (_this.isAnimatingTree && shouldStackAnimate !== true) {\n                return;\n            }\n            else if (shouldStackAnimate) {\n                _this.isAnimatingTree = true;\n            }\n            /**\n             * Allow the measured origin (prev bounding box) and target (actual layout) to be\n             * overridden by the provided config.\n             */\n            origin = originBox || origin;\n            target = targetBox || target;\n            var boxHasMoved = hasMoved(origin, target);\n            var animations = eachAxis(function (axis) {\n                /**\n                 * If layout is set to \"position\", we can resize the origin box based on the target\n                 * box and only animate its position.\n                 */\n                if (layout === \"position\") {\n                    var targetLength = target[axis].max - target[axis].min;\n                    origin[axis].max = origin[axis].min + targetLength;\n                }\n                if (visualElement.projection.isTargetLocked) {\n                    return;\n                }\n                else if (visibilityAction !== undefined) {\n                    visualElement.setVisibility(visibilityAction === VisibilityAction.Show);\n                }\n                else if (boxHasMoved) {\n                    // If the box has moved, animate between it's current visual state and its\n                    // final state\n                    return _this.animateAxis(axis, target[axis], origin[axis], config);\n                }\n                else {\n                    // If the box has remained in the same place, immediately set the axis target\n                    // to the final desired state\n                    return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max);\n                }\n            });\n            // Force a render to ensure there's no flash of uncorrected bounding box.\n            visualElement.syncRender();\n            /**\n             * If this visualElement isn't present (ie it's been removed from the tree by the user but\n             * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\n             * have successfully finished.\n             */\n            return Promise.all(animations).then(function () {\n                _this.isAnimatingTree = false;\n                onComplete && onComplete();\n                visualElement.notifyLayoutAnimationComplete();\n            });\n        };\n        return _this;\n    }\n    Animate.prototype.componentDidMount = function () {\n        var _this = this;\n        var visualElement = this.props.visualElement;\n        visualElement.animateMotionValue = startAnimation;\n        visualElement.enableLayoutProjection();\n        this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n        visualElement.layoutSafeToRemove = function () { return _this.safeToRemove(); };\n    };\n    Animate.prototype.componentWillUnmount = function () {\n        var _this = this;\n        this.unsubLayoutReady();\n        eachAxis(function (axis) { var _a, _b; return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a); });\n    };\n    /**\n     * TODO: This manually performs animations on the visualElement's layout progress\n     * values. It'd be preferable to amend the startLayoutAxisAnimation\n     * API to accept more custom animations like this.\n     */\n    Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n        var _this = this;\n        var _b, _c;\n        var transition = (_a === void 0 ? {} : _a).transition;\n        /**\n         * If we're not animating to a new target, don't run this animation\n         */\n        if (this.isAnimating[axis] &&\n            axisIsEqual(target, this.currentAnimationTarget[axis])) {\n            return;\n        }\n        (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n        this.isAnimating[axis] = true;\n        var visualElement = this.props.visualElement;\n        var frameTarget = this.frameTarget[axis];\n        var layoutProgress = visualElement.getProjectionAnimationProgress()[axis];\n        /**\n         * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\n         * be re-incoporated into a subsequent spring animation.\n         */\n        layoutProgress.clearListeners();\n        layoutProgress.set(0);\n        layoutProgress.set(0);\n        /**\n         * Create an animation function to run once per frame. This will tween the visual bounding box from\n         * origin to target using the latest progress value.\n         */\n        var frame = function () {\n            // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n            var p = layoutProgress.get() / progressTarget;\n            // Tween the axis and update the visualElement with the latest values\n            tweenAxis(frameTarget, origin, target, p);\n            visualElement.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max);\n        };\n        // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n        frame();\n        // Ensure that the layout delta is updated for this frame.\n        visualElement.updateLayoutProjection();\n        // Create a function to stop animation on this specific axis\n        var unsubscribeProgress = layoutProgress.onChange(frame);\n        this.stopAxisAnimation[axis] = function () {\n            _this.isAnimating[axis] = false;\n            layoutProgress.stop();\n            unsubscribeProgress();\n        };\n        this.currentAnimationTarget[axis] = target;\n        // Start the animation on this axis\n        var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, transition || this.props.transition || defaultTransition).then(this.stopAxisAnimation[axis]);\n        return animation;\n    };\n    Animate.prototype.safeToRemove = function () {\n        var _a, _b;\n        (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    Animate.prototype.render = function () {\n        return null;\n    };\n    return Animate;\n}(Component));\nfunction AnimateLayoutContextProvider(props) {\n    var _a = __read(usePresence(), 2), safeToRemove = _a[1];\n    return createElement(Animate, __assign({}, props, { safeToRemove: safeToRemove }));\n}\nfunction hasMoved(a, b) {\n    return (!isZeroBox(a) &&\n        !isZeroBox(b) &&\n        (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y)));\n}\nvar zeroAxis = { min: 0, max: 0 };\nfunction isZeroBox(a) {\n    return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);\n}\nfunction axisIsEqual(a, b) {\n    return a.min === b.min && a.max === b.max;\n}\nvar defaultTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\n/**\n * @public\n */\nvar AnimateLayout = {\n    key: \"animate-layout\",\n    shouldRender: function (props) {\n        return !!props.layout || props.layoutId !== undefined;\n    },\n    getComponent: function () { return AnimateLayoutContextProvider; },\n};\n\nexport { AnimateLayout };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { __read, __rest, __assign } from 'tslib';\nimport { resolveVariant } from './variants.js';\nimport { startAnimation } from '../../animation/utils/transitions.js';\nimport { setTarget } from './setters.js';\n\n/**\n * @internal\n */\nfunction animateVisualElement(visualElement, definition, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  visualElement.notifyAnimationStart();\n  var animation;\n  if (Array.isArray(definition)) {\n    var animations = definition.map(function (variant) {\n      return animateVariant(visualElement, variant, options);\n    });\n    animation = Promise.all(animations);\n  } else if (typeof definition === \"string\") {\n    animation = animateVariant(visualElement, definition, options);\n  } else {\n    var resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n    animation = animateTarget(visualElement, resolvedDefinition, options);\n  }\n  return animation.then(function () {\n    return visualElement.notifyAnimationComplete(definition);\n  });\n}\nfunction animateVariant(visualElement, variant, options) {\n  var _a;\n  if (options === void 0) {\n    options = {};\n  }\n  var resolved = resolveVariant(visualElement, variant, options.custom);\n  var _b = (resolved || {}).transition,\n    transition = _b === void 0 ? visualElement.getDefaultTransition() || {} : _b;\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\n   * If we have a variant, create a callback that runs it as an animation.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n  var getAnimation = resolved ? function () {\n    return animateTarget(visualElement, resolved, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If we have children, create a callback that runs all their animations.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n  var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function (forwardDelay) {\n    if (forwardDelay === void 0) {\n      forwardDelay = 0;\n    }\n    var _a = transition.delayChildren,\n      delayChildren = _a === void 0 ? 0 : _a,\n      staggerChildren = transition.staggerChildren,\n      staggerDirection = transition.staggerDirection;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\n   * this animation or all children animations before playing the other.\n   */\n  var when = transition.when;\n  if (when) {\n    var _c = __read(when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation], 2),\n      first = _c[0],\n      last = _c[1];\n    return first().then(last);\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\n/**\n * @internal\n */\nfunction animateTarget(visualElement, definition, _a) {\n  var _b;\n  var _c = _a === void 0 ? {} : _a,\n    _d = _c.delay,\n    delay = _d === void 0 ? 0 : _d,\n    transitionOverride = _c.transitionOverride,\n    type = _c.type;\n  var _e = visualElement.makeTargetAnimatable(definition),\n    _f = _e.transition,\n    transition = _f === void 0 ? visualElement.getDefaultTransition() : _f,\n    transitionEnd = _e.transitionEnd,\n    target = __rest(_e, [\"transition\", \"transitionEnd\"]);\n  if (transitionOverride) transition = transitionOverride;\n  var animations = [];\n  var animationTypeState = type && ((_b = visualElement.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);\n  for (var key in target) {\n    var value = visualElement.getValue(key);\n    var valueTarget = target[key];\n    if (!value || valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      continue;\n    }\n    var animation = startAnimation(key, value, valueTarget, __assign({\n      delay: delay\n    }, transition));\n    animations.push(animation);\n  }\n  return Promise.all(animations).then(function () {\n    transitionEnd && setTarget(visualElement, transitionEnd);\n  });\n}\nfunction animateChildren(visualElement, variant, delayChildren, staggerChildren, staggerDirection, options) {\n  if (delayChildren === void 0) {\n    delayChildren = 0;\n  }\n  if (staggerChildren === void 0) {\n    staggerChildren = 0;\n  }\n  if (staggerDirection === void 0) {\n    staggerDirection = 1;\n  }\n  var animations = [];\n  var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  var generateStaggerDuration = staggerDirection === 1 ? function (i) {\n    if (i === void 0) {\n      i = 0;\n    }\n    return i * staggerChildren;\n  } : function (i) {\n    if (i === void 0) {\n      i = 0;\n    }\n    return maxStaggerDuration - i * staggerChildren;\n  };\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach(function (child, i) {\n    animations.push(animateVariant(child, variant, __assign(__assign({}, options), {\n      delay: delayChildren + generateStaggerDuration(i)\n    })).then(function () {\n      return child.notifyAnimationComplete(variant);\n    }));\n  });\n  return Promise.all(animations);\n}\nfunction stopAnimation(visualElement) {\n  visualElement.forEachValue(function (value) {\n    return value.stop();\n  });\n}\nfunction sortByTreeOrder(a, b) {\n  return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation(_a, key) {\n  var protectedKeys = _a.protectedKeys,\n    needsAnimating = _a.needsAnimating;\n  var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\nexport { animateVisualElement, sortByTreeOrder, stopAnimation };","map":{"version":3,"names":["__read","__rest","__assign","resolveVariant","startAnimation","setTarget","animateVisualElement","visualElement","definition","options","notifyAnimationStart","animation","Array","isArray","animations","map","variant","animateVariant","Promise","all","resolvedDefinition","custom","animateTarget","then","notifyAnimationComplete","_a","resolved","_b","transition","getDefaultTransition","transitionOverride","getAnimation","resolve","getChildAnimations","variantChildren","size","forwardDelay","delayChildren","staggerChildren","staggerDirection","animateChildren","when","_c","first","last","delay","_d","type","_e","makeTargetAnimatable","_f","transitionEnd","target","animationTypeState","animationState","getState","key","value","getValue","valueTarget","undefined","shouldBlockAnimation","push","maxStaggerDuration","generateStaggerDuration","i","from","sort","sortByTreeOrder","forEach","child","stopAnimation","forEachValue","stop","a","b","sortNodePosition","protectedKeys","needsAnimating","shouldBlock","hasOwnProperty"],"sources":["/home/pc/Desktop/react-projects/react-projects/lazy-days/client/node_modules/framer-motion/dist/es/render/utils/animation.js"],"sourcesContent":["import { __read, __rest, __assign } from 'tslib';\nimport { resolveVariant } from './variants.js';\nimport { startAnimation } from '../../animation/utils/transitions.js';\nimport { setTarget } from './setters.js';\n\n/**\n * @internal\n */\nfunction animateVisualElement(visualElement, definition, options) {\n    if (options === void 0) { options = {}; }\n    visualElement.notifyAnimationStart();\n    var animation;\n    if (Array.isArray(definition)) {\n        var animations = definition.map(function (variant) {\n            return animateVariant(visualElement, variant, options);\n        });\n        animation = Promise.all(animations);\n    }\n    else if (typeof definition === \"string\") {\n        animation = animateVariant(visualElement, definition, options);\n    }\n    else {\n        var resolvedDefinition = typeof definition === \"function\"\n            ? resolveVariant(visualElement, definition, options.custom)\n            : definition;\n        animation = animateTarget(visualElement, resolvedDefinition, options);\n    }\n    return animation.then(function () {\n        return visualElement.notifyAnimationComplete(definition);\n    });\n}\nfunction animateVariant(visualElement, variant, options) {\n    var _a;\n    if (options === void 0) { options = {}; }\n    var resolved = resolveVariant(visualElement, variant, options.custom);\n    var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement.getDefaultTransition() || {} : _b;\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    var getAnimation = resolved\n        ? function () { return animateTarget(visualElement, resolved, options); }\n        : function () { return Promise.resolve(); };\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function (forwardDelay) {\n        if (forwardDelay === void 0) { forwardDelay = 0; }\n        var _a = transition.delayChildren, delayChildren = _a === void 0 ? 0 : _a, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;\n        return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n    }\n        : function () { return Promise.resolve(); };\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    var when = transition.when;\n    if (when) {\n        var _c = __read(when === \"beforeChildren\"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation], 2), first = _c[0], last = _c[1];\n        return first().then(last);\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\n/**\n * @internal\n */\nfunction animateTarget(visualElement, definition, _a) {\n    var _b;\n    var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;\n    var _e = visualElement.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = __rest(_e, [\"transition\", \"transitionEnd\"]);\n    if (transitionOverride)\n        transition = transitionOverride;\n    var animations = [];\n    var animationTypeState = type && ((_b = visualElement.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);\n    for (var key in target) {\n        var value = visualElement.getValue(key);\n        var valueTarget = target[key];\n        if (!value ||\n            valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        var animation = startAnimation(key, value, valueTarget, __assign({ delay: delay }, transition));\n        animations.push(animation);\n    }\n    return Promise.all(animations).then(function () {\n        transitionEnd && setTarget(visualElement, transitionEnd);\n    });\n}\nfunction animateChildren(visualElement, variant, delayChildren, staggerChildren, staggerDirection, options) {\n    if (delayChildren === void 0) { delayChildren = 0; }\n    if (staggerChildren === void 0) { staggerChildren = 0; }\n    if (staggerDirection === void 0) { staggerDirection = 1; }\n    var animations = [];\n    var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    var generateStaggerDuration = staggerDirection === 1\n        ? function (i) {\n            if (i === void 0) { i = 0; }\n            return i * staggerChildren;\n        }\n        : function (i) {\n            if (i === void 0) { i = 0; }\n            return maxStaggerDuration - i * staggerChildren;\n        };\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach(function (child, i) {\n        animations.push(animateVariant(child, variant, __assign(__assign({}, options), { delay: delayChildren + generateStaggerDuration(i) })).then(function () { return child.notifyAnimationComplete(variant); }));\n    });\n    return Promise.all(animations);\n}\nfunction stopAnimation(visualElement) {\n    visualElement.forEachValue(function (value) { return value.stop(); });\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation(_a, key) {\n    var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;\n    var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\n\nexport { animateVisualElement, sortByTreeOrder, stopAnimation };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { __assign } from 'tslib';\nimport { distance, pipe } from 'popmotion';\nimport { isMouseEvent, isTouchEvent } from './utils/event-type.js';\nimport { extractEventInfo } from '../events/event-info.js';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { secondsToMilliseconds } from '../utils/time-conversion.js';\nimport { addPointerEvent } from '../events/use-pointer-event.js';\n\n/**\n * @internal\n */\nvar PanSession = /** @class */function () {\n  function PanSession(event, handlers, _a) {\n    var _this = this;\n    var transformPagePoint = (_a === void 0 ? {} : _a).transformPagePoint;\n    /**\n     * @internal\n     */\n    this.startEvent = null;\n    /**\n     * @internal\n     */\n    this.lastMoveEvent = null;\n    /**\n     * @internal\n     */\n    this.lastMoveEventInfo = null;\n    /**\n     * @internal\n     */\n    this.handlers = {};\n    this.updatePoint = function () {\n      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo)) return;\n      var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n      var isPanStarted = _this.startEvent !== null;\n      // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursoe.\n      var isDistancePastThreshold = distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      var point = info.point;\n      var timestamp = getFrameData().timestamp;\n      _this.history.push(__assign(__assign({}, point), {\n        timestamp: timestamp\n      }));\n      var _a = _this.handlers,\n        onStart = _a.onStart,\n        onMove = _a.onMove;\n      if (!isPanStarted) {\n        onStart && onStart(_this.lastMoveEvent, info);\n        _this.startEvent = _this.lastMoveEvent;\n      }\n      onMove && onMove(_this.lastMoveEvent, info);\n    };\n    this.handlePointerMove = function (event, info) {\n      _this.lastMoveEvent = event;\n      _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);\n      // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n      if (isMouseEvent(event) && event.buttons === 0) {\n        _this.handlePointerUp(event, info);\n        return;\n      }\n      // Throttle mouse move event to once per frame\n      sync.update(_this.updatePoint, true);\n    };\n    this.handlePointerUp = function (event, info) {\n      _this.end();\n      var onEnd = _this.handlers.onEnd;\n      if (!onEnd || !_this.startEvent) return;\n      var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n      onEnd && onEnd(event, panInfo);\n    };\n    // If we have more than one touch, don't start detecting this gesture\n    if (isTouchEvent(event) && event.touches.length > 1) return;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    var info = extractEventInfo(event);\n    var initialInfo = transformPoint(info, this.transformPagePoint);\n    var point = initialInfo.point;\n    var timestamp = getFrameData().timestamp;\n    this.history = [__assign(__assign({}, point), {\n      timestamp: timestamp\n    })];\n    var onSessionStart = handlers.onSessionStart;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n  }\n  PanSession.prototype.updateHandlers = function (handlers) {\n    this.handlers = handlers;\n  };\n  PanSession.prototype.end = function () {\n    this.removeListeners && this.removeListeners();\n    cancelSync.update(this.updatePoint);\n  };\n  return PanSession;\n}();\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\nfunction subtractPoint(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\nfunction getPanInfo(_a, history) {\n  var point = _a.point;\n  return {\n    point: point,\n    delta: subtractPoint(point, lastDevicePoint(history)),\n    offset: subtractPoint(point, startDevicePoint(history)),\n    velocity: getVelocity(history, 0.1)\n  };\n}\nfunction startDevicePoint(history) {\n  return history[0];\n}\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  var i = history.length - 1;\n  var timestampedPoint = null;\n  var lastPoint = lastDevicePoint(history);\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  var currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}\nexport { PanSession };","map":{"version":3,"names":["__assign","distance","pipe","isMouseEvent","isTouchEvent","extractEventInfo","sync","getFrameData","cancelSync","secondsToMilliseconds","addPointerEvent","PanSession","event","handlers","_a","_this","transformPagePoint","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","offset","x","y","point","timestamp","push","onStart","onMove","handlePointerMove","transformPoint","buttons","handlePointerUp","update","end","onEnd","panInfo","touches","length","initialInfo","onSessionStart","removeListeners","window","prototype","updateHandlers","subtractPoint","a","b","delta","lastDevicePoint","startDevicePoint","velocity","getVelocity","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity"],"sources":["/home/pc/Desktop/react-projects/react-projects/lazy-days/client/node_modules/framer-motion/dist/es/gestures/PanSession.js"],"sourcesContent":["import { __assign } from 'tslib';\nimport { distance, pipe } from 'popmotion';\nimport { isMouseEvent, isTouchEvent } from './utils/event-type.js';\nimport { extractEventInfo } from '../events/event-info.js';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { secondsToMilliseconds } from '../utils/time-conversion.js';\nimport { addPointerEvent } from '../events/use-pointer-event.js';\n\n/**\n * @internal\n */\nvar PanSession = /** @class */ (function () {\n    function PanSession(event, handlers, _a) {\n        var _this = this;\n        var transformPagePoint = (_a === void 0 ? {} : _a).transformPagePoint;\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        this.updatePoint = function () {\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))\n                return;\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n            var isPanStarted = _this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            var isDistancePastThreshold = distance(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            var point = info.point;\n            var timestamp = getFrameData().timestamp;\n            _this.history.push(__assign(__assign({}, point), { timestamp: timestamp }));\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\n            if (!isPanStarted) {\n                onStart && onStart(_this.lastMoveEvent, info);\n                _this.startEvent = _this.lastMoveEvent;\n            }\n            onMove && onMove(_this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = function (event, info) {\n            _this.lastMoveEvent = event;\n            _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);\n            // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n            if (isMouseEvent(event) && event.buttons === 0) {\n                _this.handlePointerUp(event, info);\n                return;\n            }\n            // Throttle mouse move event to once per frame\n            sync.update(_this.updatePoint, true);\n        };\n        this.handlePointerUp = function (event, info) {\n            _this.end();\n            var onEnd = _this.handlers.onEnd;\n            if (!onEnd || !_this.startEvent)\n                return;\n            var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n            onEnd && onEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (isTouchEvent(event) && event.touches.length > 1)\n            return;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        var info = extractEventInfo(event);\n        var initialInfo = transformPoint(info, this.transformPagePoint);\n        var point = initialInfo.point;\n        var timestamp = getFrameData().timestamp;\n        this.history = [__assign(__assign({}, point), { timestamp: timestamp })];\n        var onSessionStart = handlers.onSessionStart;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n    }\n    PanSession.prototype.updateHandlers = function (handlers) {\n        this.handlers = handlers;\n    };\n    PanSession.prototype.end = function () {\n        this.removeListeners && this.removeListeners();\n        cancelSync.update(this.updatePoint);\n    };\n    return PanSession;\n}());\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo(_a, history) {\n    var point = _a.point;\n    return {\n        point: point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    var i = history.length - 1;\n    var timestampedPoint = null;\n    var lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    var currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
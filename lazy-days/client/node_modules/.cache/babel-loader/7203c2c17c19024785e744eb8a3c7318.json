{"ast":null,"code":"import { mix, distance, clamp, progress } from 'popmotion';\nvar clampProgress = function (v) {\n  return clamp(0, 1, v);\n};\n/**\n * Returns true if the provided value is within maxDistance of the provided target\n */\nfunction isNear(value, target, maxDistance) {\n  if (target === void 0) {\n    target = 0;\n  }\n  if (maxDistance === void 0) {\n    maxDistance = 0.01;\n  }\n  return distance(value, target) < maxDistance;\n}\nfunction calcLength(axis) {\n  return axis.max - axis.min;\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n  var origin = 0.5;\n  var sourceLength = calcLength(source);\n  var targetLength = calcLength(target);\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n  return clampProgress(origin);\n}\n/**\n * Update the AxisDelta with a transform that projects source into target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateAxisDelta(delta, source, target, origin) {\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n  delta.origin = origin;\n  delta.originPoint = mix(source.min, source.max, delta.origin);\n  delta.scale = calcLength(target) / calcLength(source);\n  if (isNear(delta.scale, 1, 0.0001)) delta.scale = 1;\n  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;\n  if (isNear(delta.translate)) delta.translate = 0;\n}\n/**\n * Update the BoxDelta with a transform that projects the source into the target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateBoxDelta(delta, source, target, origin) {\n  updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\n  updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\n}\n/**\n * Currently this only accepts numerical origins, measured as 0-1, but could\n * accept pixel values by comparing to the target axis.\n */\nfunction defaultOrigin(origin) {\n  return typeof origin === \"number\" ? origin : 0.5;\n}\nexport { calcOrigin, isNear, updateAxisDelta, updateBoxDelta };","map":{"version":3,"names":["mix","distance","clamp","progress","clampProgress","v","isNear","value","target","maxDistance","calcLength","axis","max","min","calcOrigin","source","origin","sourceLength","targetLength","updateAxisDelta","delta","originPoint","scale","translate","updateBoxDelta","x","defaultOrigin","originX","y","originY"],"sources":["/home/pc/Desktop/react-projects/react-projects/lazy-days/client/node_modules/framer-motion/dist/es/utils/geometry/delta-calc.js"],"sourcesContent":["import { mix, distance, clamp, progress } from 'popmotion';\n\nvar clampProgress = function (v) { return clamp(0, 1, v); };\n/**\n * Returns true if the provided value is within maxDistance of the provided target\n */\nfunction isNear(value, target, maxDistance) {\n    if (target === void 0) { target = 0; }\n    if (maxDistance === void 0) { maxDistance = 0.01; }\n    return distance(value, target) < maxDistance;\n}\nfunction calcLength(axis) {\n    return axis.max - axis.min;\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n    var origin = 0.5;\n    var sourceLength = calcLength(source);\n    var targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = progress(source.min, source.max - targetLength, target.min);\n    }\n    return clampProgress(origin);\n}\n/**\n * Update the AxisDelta with a transform that projects source into target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateAxisDelta(delta, source, target, origin) {\n    if (origin === void 0) { origin = 0.5; }\n    delta.origin = origin;\n    delta.originPoint = mix(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    if (isNear(delta.scale, 1, 0.0001))\n        delta.scale = 1;\n    delta.translate =\n        mix(target.min, target.max, delta.origin) - delta.originPoint;\n    if (isNear(delta.translate))\n        delta.translate = 0;\n}\n/**\n * Update the BoxDelta with a transform that projects the source into the target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateBoxDelta(delta, source, target, origin) {\n    updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\n    updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\n}\n/**\n * Currently this only accepts numerical origins, measured as 0-1, but could\n * accept pixel values by comparing to the target axis.\n */\nfunction defaultOrigin(origin) {\n    return typeof origin === \"number\" ? origin : 0.5;\n}\n\nexport { calcOrigin, isNear, updateAxisDelta, updateBoxDelta };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
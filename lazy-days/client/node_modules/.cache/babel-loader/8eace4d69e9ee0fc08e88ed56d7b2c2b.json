{"ast":null,"code":"import { useContext, useRef, createElement, Fragment, cloneElement, Children, isValidElement } from 'react';\nimport { __spread } from 'tslib';\nimport { SharedLayoutContext, isSharedLayout } from '../../context/SharedLayoutContext.js';\nimport { useForceUpdate } from '../../utils/use-force-update.js';\nimport { PresenceChild } from './PresenceChild.js';\nfunction getChildKey(child) {\n  return child.key || \"\";\n}\nfunction updateChildLookup(children, allChildren) {\n  var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n  children.forEach(function (child) {\n    var key = getChildKey(child);\n    if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n      if (seenChildren.has(key)) {\n        console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n      }\n      seenChildren.add(key);\n    }\n    allChildren.set(key, child);\n  });\n}\nfunction onlyElements(children) {\n  var filtered = [];\n  // We use forEach here instead of map as map mutates the component key by preprending `.$`\n  Children.forEach(children, function (child) {\n    if (isValidElement(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * @library\n *\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { Frame, AnimatePresence } from 'framer'\n *\n * // As items are added and removed from `items`\n * export function Items({ items }) {\n *   return (\n *     <AnimatePresence>\n *       {items.map(item => (\n *         <Frame\n *           key={item.id}\n *           initial={{ opacity: 0 }}\n *           animate={{ opacity: 1 }}\n *           exit={{ opacity: 0 }}\n *         />\n *       ))}\n *     </AnimatePresence>\n *   )\n * }\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * @motion\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nvar AnimatePresence = function (_a) {\n  var children = _a.children,\n    custom = _a.custom,\n    _b = _a.initial,\n    initial = _b === void 0 ? true : _b,\n    onExitComplete = _a.onExitComplete,\n    exitBeforeEnter = _a.exitBeforeEnter,\n    _c = _a.presenceAffectsLayout,\n    presenceAffectsLayout = _c === void 0 ? true : _c;\n  // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n  var forceRender = useForceUpdate();\n  var layoutContext = useContext(SharedLayoutContext);\n  if (isSharedLayout(layoutContext)) {\n    forceRender = layoutContext.forceUpdate;\n  }\n  var isInitialRender = useRef(true);\n  // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n  var filteredChildren = onlyElements(children);\n  // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n  var presentChildren = useRef(filteredChildren);\n  // A lookup table to quickly reference components by key\n  var allChildren = useRef(new Map()).current;\n  // A living record of all currently exiting components.\n  var exiting = useRef(new Set()).current;\n  updateChildLookup(filteredChildren, allChildren);\n  // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n  if (isInitialRender.current) {\n    isInitialRender.current = false;\n    return createElement(Fragment, null, filteredChildren.map(function (child) {\n      return createElement(PresenceChild, {\n        key: getChildKey(child),\n        isPresent: true,\n        initial: initial ? undefined : false,\n        presenceAffectsLayout: presenceAffectsLayout\n      }, child);\n    }));\n  }\n  // If this is a subsequent render, deal with entering and exiting children\n  var childrenToRender = __spread(filteredChildren);\n  // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n  var presentKeys = presentChildren.current.map(getChildKey);\n  var targetKeys = filteredChildren.map(getChildKey);\n  // Diff the present children with our target children and mark those that are exiting\n  var numPresent = presentKeys.length;\n  for (var i = 0; i < numPresent; i++) {\n    var key = presentKeys[i];\n    if (targetKeys.indexOf(key) === -1) {\n      exiting.add(key);\n    } else {\n      // In case this key has re-entered, remove from the exiting list\n      exiting.delete(key);\n    }\n  }\n  // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n  if (exitBeforeEnter && exiting.size) {\n    childrenToRender = [];\n  }\n  // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n  exiting.forEach(function (key) {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    var child = allChildren.get(key);\n    if (!child) return;\n    var insertionIndex = presentKeys.indexOf(key);\n    var onExit = function () {\n      allChildren.delete(key);\n      exiting.delete(key);\n      // Remove this child from the present children\n      var removeIndex = presentChildren.current.findIndex(function (presentChild) {\n        return presentChild.key === key;\n      });\n      presentChildren.current.splice(removeIndex, 1);\n      // Defer re-rendering until all exiting children have indeed left\n      if (!exiting.size) {\n        presentChildren.current = filteredChildren;\n        forceRender();\n        onExitComplete && onExitComplete();\n      }\n    };\n    childrenToRender.splice(insertionIndex, 0, createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: false,\n      onExitComplete: onExit,\n      custom: custom,\n      presenceAffectsLayout: presenceAffectsLayout\n    }, child));\n  });\n  // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n  childrenToRender = childrenToRender.map(function (child) {\n    var key = child.key;\n    return exiting.has(key) ? child : createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true,\n      presenceAffectsLayout: presenceAffectsLayout\n    }, child);\n  });\n  presentChildren.current = childrenToRender;\n  if (process.env.NODE_ENV !== \"production\" && exitBeforeEnter && childrenToRender.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n  }\n  return createElement(Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function (child) {\n    return cloneElement(child);\n  }));\n};\nexport { AnimatePresence };","map":{"version":3,"names":["useContext","useRef","createElement","Fragment","cloneElement","Children","isValidElement","__spread","SharedLayoutContext","isSharedLayout","useForceUpdate","PresenceChild","getChildKey","child","key","updateChildLookup","children","allChildren","seenChildren","process","env","NODE_ENV","Set","forEach","has","console","warn","add","set","onlyElements","filtered","push","AnimatePresence","_a","custom","_b","initial","onExitComplete","exitBeforeEnter","_c","presenceAffectsLayout","forceRender","layoutContext","forceUpdate","isInitialRender","filteredChildren","presentChildren","Map","current","exiting","map","isPresent","undefined","childrenToRender","presentKeys","targetKeys","numPresent","length","i","indexOf","delete","size","get","insertionIndex","onExit","removeIndex","findIndex","presentChild","splice"],"sources":["/home/pc/Desktop/react-projects/react-projects/lazy-days/client/node_modules/framer-motion/dist/es/components/AnimatePresence/index.js"],"sourcesContent":["import { useContext, useRef, createElement, Fragment, cloneElement, Children, isValidElement } from 'react';\nimport { __spread } from 'tslib';\nimport { SharedLayoutContext, isSharedLayout } from '../../context/SharedLayoutContext.js';\nimport { useForceUpdate } from '../../utils/use-force-update.js';\nimport { PresenceChild } from './PresenceChild.js';\n\nfunction getChildKey(child) {\n    return child.key || \"\";\n}\nfunction updateChildLookup(children, allChildren) {\n    var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n    children.forEach(function (child) {\n        var key = getChildKey(child);\n        if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n            if (seenChildren.has(key)) {\n                console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n            }\n            seenChildren.add(key);\n        }\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    var filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, function (child) {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * @library\n *\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { Frame, AnimatePresence } from 'framer'\n *\n * // As items are added and removed from `items`\n * export function Items({ items }) {\n *   return (\n *     <AnimatePresence>\n *       {items.map(item => (\n *         <Frame\n *           key={item.id}\n *           initial={{ opacity: 0 }}\n *           animate={{ opacity: 1 }}\n *           exit={{ opacity: 0 }}\n *         />\n *       ))}\n *     </AnimatePresence>\n *   )\n * }\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * @motion\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nvar AnimatePresence = function (_a) {\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    var forceRender = useForceUpdate();\n    var layoutContext = useContext(SharedLayoutContext);\n    if (isSharedLayout(layoutContext)) {\n        forceRender = layoutContext.forceUpdate;\n    }\n    var isInitialRender = useRef(true);\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    var filteredChildren = onlyElements(children);\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    var presentChildren = useRef(filteredChildren);\n    // A lookup table to quickly reference components by key\n    var allChildren = useRef(new Map())\n        .current;\n    // A living record of all currently exiting components.\n    var exiting = useRef(new Set()).current;\n    updateChildLookup(filteredChildren, allChildren);\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    if (isInitialRender.current) {\n        isInitialRender.current = false;\n        return (createElement(Fragment, null, filteredChildren.map(function (child) { return (createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout }, child)); })));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    var childrenToRender = __spread(filteredChildren);\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    var presentKeys = presentChildren.current.map(getChildKey);\n    var targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    var numPresent = presentKeys.length;\n    for (var i = 0; i < numPresent; i++) {\n        var key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1) {\n            exiting.add(key);\n        }\n        else {\n            // In case this key has re-entered, remove from the exiting list\n            exiting.delete(key);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (exitBeforeEnter && exiting.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exiting.forEach(function (key) {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        var child = allChildren.get(key);\n        if (!child)\n            return;\n        var insertionIndex = presentKeys.indexOf(key);\n        var onExit = function () {\n            allChildren.delete(key);\n            exiting.delete(key);\n            // Remove this child from the present children\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\n            presentChildren.current.splice(removeIndex, 1);\n            // Defer re-rendering until all exiting children have indeed left\n            if (!exiting.size) {\n                presentChildren.current = filteredChildren;\n                forceRender();\n                onExitComplete && onExitComplete();\n            }\n        };\n        childrenToRender.splice(insertionIndex, 0, createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map(function (child) {\n        var key = child.key;\n        return exiting.has(key) ? (child) : (createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    presentChildren.current = childrenToRender;\n    if (process.env.NODE_ENV !== \"production\" &&\n        exitBeforeEnter &&\n        childrenToRender.length > 1) {\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n    }\n    return (createElement(Fragment, null, exiting.size\n        ? childrenToRender\n        : childrenToRender.map(function (child) { return cloneElement(child); })));\n};\n\nexport { AnimatePresence };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
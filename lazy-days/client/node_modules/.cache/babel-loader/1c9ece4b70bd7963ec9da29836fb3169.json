{"ast":null,"code":"import { __rest, __assign, __read } from 'tslib';\nimport { invariant } from 'hey-listen';\nfunction isCSSVariable(value) {\n  return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n  var match = cssVariableRegex.exec(current);\n  if (!match) return [,];\n  var _a = __read(match, 3),\n    token = _a[1],\n    fallback = _a[2];\n  return [token, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth) {\n  if (depth === void 0) {\n    depth = 1;\n  }\n  invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\n  var _a = __read(parseCSSVariable(current), 2),\n    token = _a[0],\n    fallback = _a[1];\n  // No CSS variable detected\n  if (!token) return;\n  // Attempt to read this CSS variable off the element\n  var resolved = window.getComputedStyle(element).getPropertyValue(token);\n  if (resolved) {\n    return resolved.trim();\n  } else if (isCSSVariable(fallback)) {\n    // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n  var _b;\n  var target = __rest(_a, []);\n  var element = visualElement.getInstance();\n  if (!(element instanceof HTMLElement)) return {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n  // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n  // only if they change but I think this reads clearer and this isn't a performance-critical path.\n  if (transitionEnd) {\n    transitionEnd = __assign({}, transitionEnd);\n  }\n  // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n  visualElement.forEachValue(function (value) {\n    var current = value.get();\n    if (!isCSSVariable(current)) return;\n    var resolved = getVariableValue(current, element);\n    if (resolved) value.set(resolved);\n  });\n  // Cycle through every target property and resolve CSS variables. Currently\n  // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n  for (var key in target) {\n    var current = target[key];\n    if (!isCSSVariable(current)) continue;\n    var resolved = getVariableValue(current, element);\n    if (!resolved) continue;\n    // Clone target if it hasn't already been\n    target[key] = resolved;\n    // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n    // CSS variable. This will ensure that after the animation the component will reflect\n    // changes in the value of the CSS variable.\n    if (transitionEnd) (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : transitionEnd[key] = current;\n  }\n  return {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\nexport { cssVariableRegex, parseCSSVariable, resolveCSSVariables };","map":{"version":3,"names":["__rest","__assign","__read","invariant","isCSSVariable","value","startsWith","cssVariableRegex","parseCSSVariable","current","match","exec","_a","token","fallback","maxDepth","getVariableValue","element","depth","resolved","window","getComputedStyle","getPropertyValue","trim","resolveCSSVariables","visualElement","transitionEnd","_b","target","getInstance","HTMLElement","forEachValue","get","set","key"],"sources":["/home/pc/Desktop/react-projects/react-projects/lazy-days/client/node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.js"],"sourcesContent":["import { __rest, __assign, __read } from 'tslib';\nimport { invariant } from 'hey-listen';\n\nfunction isCSSVariable(value) {\n    return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n    var match = cssVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    var _a = __read(match, 3), token = _a[1], fallback = _a[2];\n    return [token, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth) {\n    if (depth === void 0) { depth = 1; }\n    invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\n    var _a = __read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    var resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        return resolved.trim();\n    }\n    else if (isCSSVariable(fallback)) {\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n        return getVariableValue(fallback, element, depth + 1);\n    }\n    else {\n        return fallback;\n    }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n    var _b;\n    var target = __rest(_a, []);\n    var element = visualElement.getInstance();\n    if (!(element instanceof HTMLElement))\n        return { target: target, transitionEnd: transitionEnd };\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\n    if (transitionEnd) {\n        transitionEnd = __assign({}, transitionEnd);\n    }\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n    visualElement.forEachValue(function (value) {\n        var current = value.get();\n        if (!isCSSVariable(current))\n            return;\n        var resolved = getVariableValue(current, element);\n        if (resolved)\n            value.set(resolved);\n    });\n    // Cycle through every target property and resolve CSS variables. Currently\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n    for (var key in target) {\n        var current = target[key];\n        if (!isCSSVariable(current))\n            continue;\n        var resolved = getVariableValue(current, element);\n        if (!resolved)\n            continue;\n        // Clone target if it hasn't already been\n        target[key] = resolved;\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n        // CSS variable. This will ensure that after the animation the component will reflect\n        // changes in the value of the CSS variable.\n        if (transitionEnd)\n            (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : (transitionEnd[key] = current);\n    }\n    return { target: target, transitionEnd: transitionEnd };\n}\n\nexport { cssVariableRegex, parseCSSVariable, resolveCSSVariables };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
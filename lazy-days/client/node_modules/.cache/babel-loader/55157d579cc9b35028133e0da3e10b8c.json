{"ast":null,"code":"import { createElement, Component } from 'react';\nimport { __extends, __assign } from 'tslib';\nimport { MotionContext } from '../../context/MotionContext/index.js';\nimport { Presence } from './types.js';\nimport { createBatcher } from './utils/batcher.js';\nimport { SharedLayoutContext } from '../../context/SharedLayoutContext.js';\nimport { layoutStack } from './utils/stack.js';\nimport { resetRotate } from './utils/rotate.js';\n\n/**\n * @public\n */\nvar AnimateSharedLayout = /** @class */function (_super) {\n  __extends(AnimateSharedLayout, _super);\n  function AnimateSharedLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A list of all the children in the shared layout\n     */\n    _this.children = new Set();\n    /**\n     * As animate components with a defined `layoutId` are added/removed to the tree,\n     * we store them in order. When one is added, it will animate out from the\n     * previous one, and when it's removed, it'll animate to the previous one.\n     */\n    _this.stacks = new Map();\n    /**\n     * Track whether the component has mounted. If it hasn't, the presence of added children\n     * are set to Present, whereas if it has they're considered Entering\n     */\n    _this.hasMounted = false;\n    /**\n     * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n     * and schedule one.\n     */\n    _this.updateScheduled = false;\n    /**\n     * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n     */\n    _this.renderScheduled = false;\n    /**\n     * The methods provided to all children in the shared layout tree.\n     */\n    _this.syncContext = __assign(__assign({}, createBatcher()), {\n      syncUpdate: function (force) {\n        return _this.scheduleUpdate(force);\n      },\n      forceUpdate: function () {\n        // By copying syncContext to itself, when this component re-renders it'll also re-render\n        // all children subscribed to the SharedLayout context.\n        _this.syncContext = __assign({}, _this.syncContext);\n        _this.scheduleUpdate(true);\n      },\n      register: function (child) {\n        return _this.addChild(child);\n      },\n      remove: function (child) {\n        return _this.removeChild(child);\n      }\n    });\n    return _this;\n  }\n  AnimateSharedLayout.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n  };\n  AnimateSharedLayout.prototype.componentDidUpdate = function () {\n    this.startLayoutAnimation();\n  };\n  AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n    this.renderScheduled = true;\n    return true;\n  };\n  AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n    var _this = this;\n    /**\n     * Reset update and render scheduled status\n     */\n    this.renderScheduled = this.updateScheduled = false;\n    var type = this.props.type;\n    /**\n     * Update presence metadata based on the latest AnimatePresence status.\n     * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n     */\n    this.children.forEach(function (child) {\n      if (!child.isPresent) {\n        child.presence = Presence.Exiting;\n      } else if (child.presence !== Presence.Entering) {\n        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;\n      }\n    });\n    this.updateStacks();\n    /**\n     * Create a handler which we can use to flush the children animations\n     */\n    var handler = {\n      measureLayout: function (child) {\n        return child.updateLayoutMeasurement();\n      },\n      layoutReady: function (child) {\n        if (child.getLayoutId() !== undefined) {\n          var stack = _this.getStack(child);\n          stack.animate(child, type === \"crossfade\");\n        } else {\n          child.notifyLayoutReady();\n        }\n      },\n      parent: this.context.visualElement\n    };\n    /**\n     * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n     * This requires some co-ordination across components to stop layout thrashing\n     * and ensure measurements are taken at the correct time.\n     *\n     * Here we use that same mechanism of schedule/flush.\n     */\n    this.children.forEach(function (child) {\n      return _this.syncContext.add(child);\n    });\n    this.syncContext.flush(handler);\n    /**\n     * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n     */\n    this.stacks.forEach(function (stack) {\n      return stack.clearSnapshot();\n    });\n  };\n  AnimateSharedLayout.prototype.updateStacks = function () {\n    this.stacks.forEach(function (stack) {\n      return stack.updateLeadAndFollow();\n    });\n  };\n  AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n    if (!(force || !this.updateScheduled)) return;\n    /**\n     * Flag we've scheduled an update\n     */\n    this.updateScheduled = true;\n    /**\n     * Write: Reset rotation transforms so bounding boxes can be accurately measured.\n     */\n    this.children.forEach(function (child) {\n      return resetRotate(child);\n    });\n    /**\n     * Read: Snapshot children\n     */\n    this.children.forEach(function (child) {\n      return child.snapshotViewportBox();\n    });\n    /**\n     * Every child keeps a local snapshot, but we also want to record\n     * snapshots of the visible children as, if they're are being removed\n     * in this render, we can still access them.\n     *\n     * TODO: What would be better here is doing a single loop where we\n     * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n     */\n    this.stacks.forEach(function (stack) {\n      return stack.updateSnapshot();\n    });\n    /**\n     * Force a rerender by setting state if we aren't already going to render.\n     */\n    if (force || !this.renderScheduled) {\n      this.renderScheduled = true;\n      this.forceUpdate();\n    }\n  };\n  AnimateSharedLayout.prototype.addChild = function (child) {\n    this.children.add(child);\n    this.addToStack(child);\n    child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n  };\n  AnimateSharedLayout.prototype.removeChild = function (child) {\n    this.scheduleUpdate();\n    this.children.delete(child);\n    this.removeFromStack(child);\n  };\n  AnimateSharedLayout.prototype.addToStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.add(child);\n  };\n  AnimateSharedLayout.prototype.removeFromStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.remove(child);\n  };\n  /**\n   * Return a stack of animate children based on the provided layoutId.\n   * Will create a stack if none currently exists with that layoutId.\n   */\n  AnimateSharedLayout.prototype.getStack = function (child) {\n    var id = child.getLayoutId();\n    if (id === undefined) return;\n    // Create stack if it doesn't already exist\n    !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n    return this.stacks.get(id);\n  };\n  AnimateSharedLayout.prototype.render = function () {\n    return createElement(SharedLayoutContext.Provider, {\n      value: this.syncContext\n    }, this.props.children);\n  };\n  AnimateSharedLayout.contextType = MotionContext;\n  return AnimateSharedLayout;\n}(Component);\nexport { AnimateSharedLayout };","map":{"version":3,"names":["createElement","Component","__extends","__assign","MotionContext","Presence","createBatcher","SharedLayoutContext","layoutStack","resetRotate","AnimateSharedLayout","_super","_this","apply","arguments","children","Set","stacks","Map","hasMounted","updateScheduled","renderScheduled","syncContext","syncUpdate","force","scheduleUpdate","forceUpdate","register","child","addChild","remove","removeChild","prototype","componentDidMount","componentDidUpdate","startLayoutAnimation","shouldComponentUpdate","type","props","forEach","isPresent","presence","Exiting","Entering","Present","updateStacks","handler","measureLayout","updateLayoutMeasurement","layoutReady","getLayoutId","undefined","stack","getStack","animate","notifyLayoutReady","parent","context","visualElement","add","flush","clearSnapshot","updateLeadAndFollow","snapshotViewportBox","updateSnapshot","addToStack","delete","removeFromStack","id","has","set","get","render","Provider","value","contextType"],"sources":["/home/pc/Desktop/react-projects/react-projects/lazy-days/client/node_modules/framer-motion/dist/es/components/AnimateSharedLayout/index.js"],"sourcesContent":["import { createElement, Component } from 'react';\nimport { __extends, __assign } from 'tslib';\nimport { MotionContext } from '../../context/MotionContext/index.js';\nimport { Presence } from './types.js';\nimport { createBatcher } from './utils/batcher.js';\nimport { SharedLayoutContext } from '../../context/SharedLayoutContext.js';\nimport { layoutStack } from './utils/stack.js';\nimport { resetRotate } from './utils/rotate.js';\n\n/**\n * @public\n */\nvar AnimateSharedLayout = /** @class */ (function (_super) {\n    __extends(AnimateSharedLayout, _super);\n    function AnimateSharedLayout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A list of all the children in the shared layout\n         */\n        _this.children = new Set();\n        /**\n         * As animate components with a defined `layoutId` are added/removed to the tree,\n         * we store them in order. When one is added, it will animate out from the\n         * previous one, and when it's removed, it'll animate to the previous one.\n         */\n        _this.stacks = new Map();\n        /**\n         * Track whether the component has mounted. If it hasn't, the presence of added children\n         * are set to Present, whereas if it has they're considered Entering\n         */\n        _this.hasMounted = false;\n        /**\n         * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n         * and schedule one.\n         */\n        _this.updateScheduled = false;\n        /**\n         * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n         */\n        _this.renderScheduled = false;\n        /**\n         * The methods provided to all children in the shared layout tree.\n         */\n        _this.syncContext = __assign(__assign({}, createBatcher()), { syncUpdate: function (force) { return _this.scheduleUpdate(force); }, forceUpdate: function () {\n                // By copying syncContext to itself, when this component re-renders it'll also re-render\n                // all children subscribed to the SharedLayout context.\n                _this.syncContext = __assign({}, _this.syncContext);\n                _this.scheduleUpdate(true);\n            }, register: function (child) { return _this.addChild(child); }, remove: function (child) { return _this.removeChild(child); } });\n        return _this;\n    }\n    AnimateSharedLayout.prototype.componentDidMount = function () {\n        this.hasMounted = true;\n    };\n    AnimateSharedLayout.prototype.componentDidUpdate = function () {\n        this.startLayoutAnimation();\n    };\n    AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n        this.renderScheduled = true;\n        return true;\n    };\n    AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n        var _this = this;\n        /**\n         * Reset update and render scheduled status\n         */\n        this.renderScheduled = this.updateScheduled = false;\n        var type = this.props.type;\n        /**\n         * Update presence metadata based on the latest AnimatePresence status.\n         * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n         */\n        this.children.forEach(function (child) {\n            if (!child.isPresent) {\n                child.presence = Presence.Exiting;\n            }\n            else if (child.presence !== Presence.Entering) {\n                child.presence =\n                    child.presence === Presence.Exiting\n                        ? Presence.Entering\n                        : Presence.Present;\n            }\n        });\n        this.updateStacks();\n        /**\n         * Create a handler which we can use to flush the children animations\n         */\n        var handler = {\n            measureLayout: function (child) { return child.updateLayoutMeasurement(); },\n            layoutReady: function (child) {\n                if (child.getLayoutId() !== undefined) {\n                    var stack = _this.getStack(child);\n                    stack.animate(child, type === \"crossfade\");\n                }\n                else {\n                    child.notifyLayoutReady();\n                }\n            },\n            parent: this.context.visualElement,\n        };\n        /**\n         * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n         * This requires some co-ordination across components to stop layout thrashing\n         * and ensure measurements are taken at the correct time.\n         *\n         * Here we use that same mechanism of schedule/flush.\n         */\n        this.children.forEach(function (child) { return _this.syncContext.add(child); });\n        this.syncContext.flush(handler);\n        /**\n         * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n         */\n        this.stacks.forEach(function (stack) { return stack.clearSnapshot(); });\n    };\n    AnimateSharedLayout.prototype.updateStacks = function () {\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\n    };\n    AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n        if (force === void 0) { force = false; }\n        if (!(force || !this.updateScheduled))\n            return;\n        /**\n         * Flag we've scheduled an update\n         */\n        this.updateScheduled = true;\n        /**\n         * Write: Reset rotation transforms so bounding boxes can be accurately measured.\n         */\n        this.children.forEach(function (child) { return resetRotate(child); });\n        /**\n         * Read: Snapshot children\n         */\n        this.children.forEach(function (child) { return child.snapshotViewportBox(); });\n        /**\n         * Every child keeps a local snapshot, but we also want to record\n         * snapshots of the visible children as, if they're are being removed\n         * in this render, we can still access them.\n         *\n         * TODO: What would be better here is doing a single loop where we\n         * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n         */\n        this.stacks.forEach(function (stack) { return stack.updateSnapshot(); });\n        /**\n         * Force a rerender by setting state if we aren't already going to render.\n         */\n        if (force || !this.renderScheduled) {\n            this.renderScheduled = true;\n            this.forceUpdate();\n        }\n    };\n    AnimateSharedLayout.prototype.addChild = function (child) {\n        this.children.add(child);\n        this.addToStack(child);\n        child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n    };\n    AnimateSharedLayout.prototype.removeChild = function (child) {\n        this.scheduleUpdate();\n        this.children.delete(child);\n        this.removeFromStack(child);\n    };\n    AnimateSharedLayout.prototype.addToStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.add(child);\n    };\n    AnimateSharedLayout.prototype.removeFromStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.remove(child);\n    };\n    /**\n     * Return a stack of animate children based on the provided layoutId.\n     * Will create a stack if none currently exists with that layoutId.\n     */\n    AnimateSharedLayout.prototype.getStack = function (child) {\n        var id = child.getLayoutId();\n        if (id === undefined)\n            return;\n        // Create stack if it doesn't already exist\n        !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n        return this.stacks.get(id);\n    };\n    AnimateSharedLayout.prototype.render = function () {\n        return (createElement(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children));\n    };\n    AnimateSharedLayout.contextType = MotionContext;\n    return AnimateSharedLayout;\n}(Component));\n\nexport { AnimateSharedLayout };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}